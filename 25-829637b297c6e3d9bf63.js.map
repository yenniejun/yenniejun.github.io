{"version":3,"sources":["webpack:///../src/components/intersection-observer.ts","webpack:///./node_modules/core-js/modules/es6.weak-map.js","webpack:///./node_modules/core-js/modules/_collection-weak.js"],"names":["intersectionObserver","ioEntryMap","WeakMap","connection","navigator","mozConnection","webkitConnection","createIntersectionObserver","callback","window","IntersectionObserver","entries","forEach","entry","isIntersecting","get","target","rootMargin","effectiveType","saveData","element","current","set","observe","unobserve","InternalMap","global","each","redefine","meta","assign","weak","isObject","validate","NATIVE_WEAK_MAP","IS_IE11","ActiveXObject","getWeak","isExtensible","Object","uncaughtFrozenStore","ufstore","wrapper","this","arguments","length","undefined","methods","key","data","_i","value","def","$WeakMap","module","exports","getConstructor","prototype","NEED","proto","method","a","b","_f","result","call","redefineAll","anObject","anInstance","forOf","createArrayMethod","$has","arrayFind","arrayFindIndex","id","that","_l","UncaughtFrozenStore","findUncaughtFrozen","store","it","has","push","index","splice","NAME","IS_MAP","ADDER","C","iterable","_t"],"mappings":"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","file":"25-829637b297c6e3d9bf63.js","sourcesContent":["/* eslint-disable no-unused-expressions */\nimport { RefObject } from \"react\"\n\nlet intersectionObserver: IntersectionObserver\n\nexport type Unobserver = () => void\n\nconst ioEntryMap = new WeakMap<HTMLElement, () => void>()\n/* eslint-disable @typescript-eslint/no-explicit-any  */\nconst connection =\n  (navigator as any).connection ||\n  (navigator as any).mozConnection ||\n  (navigator as any).webkitConnection\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n// These match the thresholds used in Chrome's native lazy loading\n// @see https://web.dev/browser-level-image-lazy-loading/#distance-from-viewport-thresholds\nconst FAST_CONNECTION_THRESHOLD = `1250px`\nconst SLOW_CONNECTION_THRESHOLD = `2500px`\n\nexport function createIntersectionObserver(\n  callback: () => void\n): (element: RefObject<HTMLElement | undefined>) => Unobserver {\n  const connectionType = connection?.effectiveType\n\n  // if we don't support intersectionObserver we don't lazy load (Sorry IE 11).\n  if (!(`IntersectionObserver` in window)) {\n    return function observe(): Unobserver {\n      callback()\n      return function unobserve(): void {}\n    }\n  }\n\n  if (!intersectionObserver) {\n    intersectionObserver = new IntersectionObserver(\n      entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            // Get the matching entry's callback and call it\n            ioEntryMap.get(entry.target as HTMLElement)?.()\n            // We only need to call it once\n            ioEntryMap.delete(entry.target as HTMLElement)\n          }\n        })\n      },\n      {\n        rootMargin:\n          connectionType === `4g` && !connection?.saveData\n            ? FAST_CONNECTION_THRESHOLD\n            : SLOW_CONNECTION_THRESHOLD,\n      }\n    )\n  }\n\n  return function observe(\n    element: RefObject<HTMLElement | undefined>\n  ): Unobserver {\n    if (element.current) {\n      // Store a reference to the callback mapped to the element being watched\n      ioEntryMap.set(element.current, callback)\n      intersectionObserver.observe(element.current)\n    }\n\n    return function unobserve(): void {\n      if (intersectionObserver && element.current) {\n        ioEntryMap.delete(element.current)\n        intersectionObserver.unobserve(element.current)\n      }\n    }\n  }\n}\n","'use strict';\nvar global = require('./_global');\nvar each = require('./_array-methods')(0);\nvar redefine = require('./_redefine');\nvar meta = require('./_meta');\nvar assign = require('./_object-assign');\nvar weak = require('./_collection-weak');\nvar isObject = require('./_is-object');\nvar validate = require('./_validate-collection');\nvar NATIVE_WEAK_MAP = require('./_validate-collection');\nvar IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (NATIVE_WEAK_MAP && IS_IE11) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n","'use strict';\nvar redefineAll = require('./_redefine-all');\nvar getWeak = require('./_meta').getWeak;\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar createArrayMethod = require('./_array-methods');\nvar $has = require('./_has');\nvar validate = require('./_validate-collection');\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n"],"sourceRoot":""}